#!/usr/bin/env node
"use strict";var N=Object.create;var x=Object.defineProperty;var _=Object.getOwnPropertyDescriptor;var A=Object.getOwnPropertyNames;var F=Object.getPrototypeOf,U=Object.prototype.hasOwnProperty;var n=(o,e)=>x(o,"name",{value:e,configurable:!0});var L=(o,e,t,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of A(e))!U.call(o,i)&&i!==t&&x(o,i,{get:()=>e[i],enumerable:!(r=_(e,i))||r.enumerable});return o};var g=(o,e,t)=>(t=o!=null?N(F(o)):{},L(e||!o||!o.__esModule?x(t,"default",{value:o,enumerable:!0}):t,o));var j=g(require("pino"));function y(o){return o instanceof Error&&"exitCode"in o&&typeof o.exitCode=="number"}n(y,"isRiptideError");var w=g(require("pino"));function P(o){let{level:e="info",format:t="pretty",serviceName:r}=o,i={level:e,timestamp:w.default.stdTimeFunctions.isoTime,formatters:{log:n(s=>({service:r,...s}),"log"),bindings:n(s=>{let{pid:a,hostname:c,...d}=s;return d},"bindings")}};return t==="pretty"&&!process.env.NODE_ENV?.includes("prod")?(0,w.default)({...i,transport:{target:"pino-pretty",options:{colorize:!0,translateTime:"SYS:standard",ignore:"pid,hostname"}}}):(0,w.default)(i)}n(P,"createLogger");var R=require("child_process"),f=require("fs"),W=g(require("http")),Y=g(require("https")),b=g(require("path")),O=require("util");var V=(0,O.promisify)(R.exec);function H(){return{sleep:n(o=>new Promise(e=>setTimeout(e,o)),"sleep"),retry:n(async(o,e={})=>{let{maxAttempts:t=3,delay:r=1e3,backoffMultiplier:i=2,maxDelay:s=3e4}=e,a,c=r;for(let d=1;d<=t;d++)try{return await o()}catch(p){if(a=p instanceof Error?p:new Error(String(p)),d===t)throw a;await new Promise(m=>setTimeout(m,Math.min(c,s))),c*=i}throw a},"retry"),execCommand:n(async(o,e={})=>{let{timeout:t=3e4,cwd:r=process.cwd(),env:i=process.env}=e;try{let{stdout:s,stderr:a}=await V(o,{timeout:t,cwd:r,env:{...process.env,...i}});return{stdout:s.trim(),stderr:a.trim(),exitCode:0}}catch(s){if(s.killed&&s.signal==="SIGTERM"){let c=`Command timed out after ${t/1e3}s. Consider increasing timeout if command needs more time to complete: utils.execCommand('${o}', { timeout: ${t*2} })`,d=s.stderr?.trim()||"",p=d?`${d}

${c}`:c,m=[];s.stdout?.trim()&&m.push(`STDOUT: ${s.stdout.trim()}`),p&&m.push(`STDERR: ${p}`);let M=[`Command execution timed out: ${o}`,...m].join(`

`),E=new Error(M);throw E.name="CommandTimeoutError",E}return{stdout:s.stdout?.trim()||"",stderr:s.stderr?.trim()||s.message,exitCode:s.code||1}}},"execCommand"),writeFile:n(async(o,e,t={})=>{let{mode:r="0644",encoding:i="utf8"}=t;await f.promises.mkdir(b.dirname(o),{recursive:!0}),await f.promises.writeFile(o,e,{encoding:i}),await f.promises.chmod(o,r)},"writeFile"),readFile:n(async o=>await f.promises.readFile(o,"utf8"),"readFile"),fileExists:n(async o=>{try{return await f.promises.access(o),!0}catch{return!1}},"fileExists"),downloadFile:n(async function o(e,t){return new Promise((r,i)=>{let s=b.dirname(t);f.promises.mkdir(s,{recursive:!0}).then(()=>{let a=(0,f.createWriteStream)(t);(e.startsWith("https:")?Y:W).get(e,p=>{if(p.statusCode===200)p.pipe(a),a.on("finish",()=>{a.close(),r(t)});else if(p.statusCode===301||p.statusCode===302){let m=p.headers.location;m?r(o(m,t)):i(new Error(`Redirect without location header: ${p.statusCode}`))}else i(new Error(`Failed to download: ${p.statusCode} ${p.statusMessage}`))}).on("error",p=>{f.promises.unlink(t).catch(()=>{}),i(p)}),a.on("error",p=>{f.promises.unlink(t).catch(()=>{}),i(p)})}).catch(i)})},"downloadFile")}}n(H,"createUtilityContext");var I=require("http");var k=class{constructor(e,t,r,i,s){this.getStatus=r;this.executeHealthCheck=i;this.getMetrics=s;this.port=e,this.logger=t.child({component:"web-server"})}static{n(this,"WebServer")}server=null;port;logger;async start(){if(this.server){this.logger.warn("Web server already running");return}return this.server=(0,I.createServer)(async(e,t)=>{if(e.method!=="GET"){t.writeHead(405,{"Content-Type":"application/json"}),t.end(JSON.stringify({error:"Method not allowed"}));return}if(e.url==="/health")try{let r=await this.executeHealthCheck(),i=this.getStatus(),s={healthy:r,status:i.status,uptime:i.uptime,message:i.message};r?t.writeHead(200,{"Content-Type":"application/json"}):t.writeHead(503,{"Content-Type":"application/json"}),t.end(JSON.stringify(s))}catch(r){this.logger.error({error:r},"Health check endpoint error"),t.writeHead(500,{"Content-Type":"application/json"}),t.end(JSON.stringify({healthy:!1,error:r instanceof Error?r.message:"Internal server error"}))}else if(e.url==="/metrics")try{let r=await this.getMetrics();t.writeHead(200,{"Content-Type":"text/plain; version=0.0.4"}),t.end(r)}catch(r){this.logger.error({error:r},"Metrics endpoint error"),t.writeHead(500,{"Content-Type":"application/json"}),t.end(JSON.stringify({error:r instanceof Error?r.message:"Internal server error"}))}else t.writeHead(404,{"Content-Type":"application/json"}),t.end(JSON.stringify({error:"Not found"}))}),new Promise((e,t)=>{this.server.once("error",r=>{this.logger.error({error:r,port:this.port},"Failed to start web server"),t(r)}),this.server.listen(this.port,()=>{e()})})}async stop(){if(this.server)return new Promise(e=>{this.server.close(()=>{this.logger.info("Web server stopped"),this.server=null,e()})})}};var S=class{static{n(this,"RiptideEntrypoint")}logger;hooks;config;isShuttingDown=!1;status={status:"starting"};startTime;heartbeatInterval;webServer;constructor(e,t,r={}){this.hooks=e,this.config=t,this.startTime=Date.now(),this.logger=P({serviceName:t.service.name,level:r.logLevel||t.logging?.level||"info",format:process.env.NODE_ENV==="production"?"json":t.logging?.format||"pretty"}),this.setupGlobalErrorHandlers(),this.setupSignalHandlers()}async start(){try{let e=this.config.service.version||"unknown",t=process.env.NODE_ENV||"production";this.logger.info({version:e,environment:t},`Starting ${this.config.service.name}`),await this.processSecrets(),await this.executeHook("start"),await this.startWebServer(this.config.health?.port||3e3),this.startHeartbeat(),this.status={status:"healthy",uptime:Date.now()-this.startTime,message:"Service started successfully"},this.logger.info({service:this.config.service.name},`${this.config.service.name} service is ready`),await this.waitForShutdown()}catch(e){this.logger.error({error:e instanceof Error?e.message:String(e),stack:e instanceof Error?e.stack:void 0},`Failed to start ${this.config.service.name} service`),this.status={status:"unhealthy",message:e instanceof Error?e.message:String(e)},y(e)?(this.logger.error(`Exiting with code ${e.exitCode} (${e.name})`),process.exit(e.exitCode)):process.exit(1)}}async processSecrets(){if(!this.hooks.installSecrets){this.logger.info("No installSecrets hook, continuing...");return}this.logger.info("Processing secrets...");try{await this.executeHook("installSecrets")}catch(e){throw this.logger.error({error:e instanceof Error?e.message:String(e),stack:e instanceof Error?e.stack:void 0,hookName:"installSecrets"},"Failed to install secrets"),e}}async executeHook(e){let t=this.hooks[e];if(typeof t!="function")throw new Error(`Required hook '${e}' not found`);let r=this.createHookContext(),i=Date.now();try{let s=await t(r),a=Date.now()-i;return this.logger.debug(`Hook ${e} completed in ${a}ms`),s}catch(s){let a=Date.now()-i;throw this.logger.error({hookName:e,duration:a,error:s instanceof Error?s.message:String(s),stack:s instanceof Error?s.stack:void 0},"Hook threw an exception, will not continue"),s}}async executeHookSafely(e){if(typeof this.hooks[e]!="function")return this.logger.debug(`Optional hook '${e}' not found, skipping`),null;try{return await this.executeHook(e)}catch(r){return this.logger.warn({hookName:e,error:r instanceof Error?r.message:String(r)},"Optional hook execution failed but continuing"),null}}createHookContext(){return{config:this.config,logger:this.logger,env:process.env,utils:H()}}setupGlobalErrorHandlers(){process.on("uncaughtException",e=>{this.logger.error({error:e.message,stack:e.stack},"Uncaught exception"),y(e)?(this.logger.info(`Exiting with code ${e.exitCode} (${e.name}) from unhandled exception`),process.exit(e.exitCode)):(this.logger.error("Exiting with code 1 due to unhandled exception"),process.exit(1))}),process.on("unhandledRejection",(e,t)=>{this.logger.error({reason:e,promise:t},"Unhandled promise rejection"),y(e)?(this.logger.info(`Exiting with code ${e.exitCode} (${e.name}) from unhandled rejection`),process.exit(e.exitCode)):(this.logger.error("Exiting with code 1 due to unhandled promise rejection"),process.exit(1))})}setupSignalHandlers(){let e=n(async t=>{this.isShuttingDown&&(this.logger.warn("Force shutdown signal received"),process.exit(1)),this.isShuttingDown=!0,this.status={status:"stopping",message:`Received ${t} signal`},this.logger.info(`${t} signal received, starting graceful shutdown...`);try{this.heartbeatInterval&&clearInterval(this.heartbeatInterval),this.webServer&&await this.webServer.stop(),await this.executeHookSafely("stop"),this.status={status:"stopped",message:"Graceful shutdown completed"},this.logger.info("Graceful shutdown completed"),process.exit(0)}catch(r){this.logger.error({error:r instanceof Error?r.message:String(r)},"Error during graceful shutdown"),process.exit(1)}},"gracefulShutdown");process.on("SIGTERM",()=>e("SIGTERM")),process.on("SIGINT",()=>e("SIGINT"))}startHeartbeat(){if(!this.hooks.heartbeat){this.logger.info("No heartbeat hook defined, skipping heartbeat");return}if(!this.config.heartbeat?.enabled){this.logger.info("Heartbeat disabled in config, skipping...");return}let e=this.config.heartbeat?.interval||6e4;this.logger.info({interval:e},"Starting heartbeat");let t=!1;this.heartbeatInterval=setInterval(async()=>{if(t){this.logger.info("Heartbeat still executing, skipping this interval");return}t=!0;try{let r=await this.executeHookSafely("heartbeat");if(r===null){this.logger.info("Heartbeat hook returned null, skipping heartbeat");return}await this.pingSonar(r)}catch(r){this.logger.warn({error:r instanceof Error?r.message:String(r)},"Heartbeat execution failed")}finally{t=!1}},e)}async pingSonar(e){let t=process.env.SONAR_API_URL,r=process.env.SONAR_API_KEY,i=process.env.NOMAD_JOB_NAME;if(!t||!r||!i){this.logger.info({hasUrl:!!t,hasKey:!!r,hasJobId:!!i},"Sonar API configuration incomplete, skipping heartbeat send");return}let s=Math.floor(Date.now()/1e3),a={entity_id:i,client_timestamp:s,metadata:e};try{this.logger.info({payload:a,sonarUrl:t,sonarApiKey:r,nomadJobId:i},"Sending heartbeat to Sonar API");let c=await fetch(`${t}/api/v1/heartbeat`,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${r}`},body:JSON.stringify(a)});if(!c.ok){let d=await c.text();this.logger.warn({status:c.status,error:d,entity_id:i},"Sonar API heartbeat failed")}}catch(c){this.logger.error({error:c instanceof Error?c.message:String(c),errorType:c?.constructor?.name,errorCause:c instanceof Error&&"cause"in c?c.cause:void 0,stack:c instanceof Error?c.stack:void 0,url:`${t}/api/v1/heartbeat`,entity_id:i},"Failed to send heartbeat to Sonar API")}}async startWebServer(e){this.webServer=new k(e,this.logger,()=>({...this.status,uptime:Date.now()-this.startTime}),async()=>await this.executeHookSafely("health")===!0,async()=>await this.getMetrics());try{await this.webServer.start()}catch(t){this.logger.error({error:t,port:e},"Failed to start web server")}}async waitForShutdown(){return new Promise(e=>{let t=n(()=>{this.isShuttingDown?e():setTimeout(t,100)},"checkShutdown");t()})}async getMetrics(){if(!this.hooks.metrics)return{uptime:Date.now()-this.startTime,status:this.status.status};try{return await this.executeHookSafely("metrics")}catch{return{uptime:Date.now()-this.startTime,status:this.status.status}}}};var h=g(require("fs/promises")),l=g(require("path"));var C=class{constructor(e){this.logger=e}static{n(this,"ServiceScaffolder")}async scaffold(e){let{serviceName:t,targetPath:r=".",template:i="basic",description:s}=e,a=l.join(r,t);this.logger.info(`Creating new Coral Reef service: ${t}`),this.logger.info(`Template: ${i}`),this.logger.info(`Location: ${a}`),await this.createDirectoryStructure(a),await this.createPackageJson(a,t,s),await this.createRiptideConfig(a,t,s),await this.createTsConfig(a),await this.createTsupConfig(a),await this.createHooks(a,i),await this.createDockerfile(a,t),this.logger.info("\u2705 Service scaffolding complete!"),this.showNextSteps(t,a)}async createDirectoryStructure(e){await h.mkdir(l.join(e,"src"),{recursive:!0})}async createPackageJson(e,t,r){let i=await this.checkIfInWorkspace(e),s=i?"workspace:*":await this.getRiptideVersion(),a=i?`cd ../.. && docker build --platform \${DOCKER_PLATFORM:-linux/amd64} --progress=plain -t reef-${t} -f services/${t}/Dockerfile .`:`docker build --platform \${DOCKER_PLATFORM:-linux/amd64} --progress=plain -t reef-${t} .`,c={name:`reef-${t}`,version:"1.0.0",description:r||`${t} service for Coral Reef`,main:"dist/hooks.js",scripts:{build:"tsc --noEmit && tsup","build:docker":a,clean:"rm -rf dist",start:"npx @deeep-network/riptide start --hooks dist/hooks.js",validate:"pnpm run build && npx @deeep-network/riptide validate --hooks dist/hooks.js","type-check":"tsc --noEmit"},dependencies:{"@deeep-network/riptide":s},devDependencies:{typescript:"^5.8.3",tsup:"^8.5.0","@types/node":"^20.0.0"},engines:{node:">=22.0.0"}};await h.writeFile(l.join(e,"package.json"),JSON.stringify(c,null,2))}async createRiptideConfig(e,t,r){let i={service:{name:t,version:"1.0.0",description:r||`${t} service`},logging:{level:"info"}};await h.writeFile(l.join(e,"riptide.config.json"),JSON.stringify(i,null,2))}async createTsConfig(e){let r=await this.checkIfInWorkspace(e)?{extends:"../../tsconfig.json",compilerOptions:{outDir:"./dist",rootDir:"./src",declaration:!0,declarationMap:!0,sourceMap:!0},include:["src/**/*"],exclude:["dist","node_modules"]}:{compilerOptions:{target:"ES2022",module:"commonjs",lib:["ES2022"],outDir:"./dist",rootDir:"./src",strict:!0,esModuleInterop:!0,skipLibCheck:!0,forceConsistentCasingInFileNames:!0,declaration:!0,declarationMap:!0,sourceMap:!0,moduleResolution:"node"},include:["src/**/*"],exclude:["dist","node_modules"]};await h.writeFile(l.join(e,"tsconfig.json"),JSON.stringify(r,null,2))}async createTsupConfig(e){await h.writeFile(l.join(e,"tsup.config.ts"),`import { defineConfig } from 'tsup'

export default defineConfig({
  entry: ['src/hooks.ts'],
  format: ['cjs'],
  target: 'node22',
  outDir: 'dist',
  clean: true,
  minify: false,
  sourcemap: true
})
`)}async createHooks(e,t){let r="";switch(t){case"with-secrets":r=this.getHooksWithSecrets();break;case"with-process":r=this.getHooksWithProcess();break;case"with-metrics":r=this.getHooksWithMetrics();break;default:r=this.getBasicHooks()}await h.writeFile(l.join(e,"src","hooks.ts"),r)}getBasicHooks(){return`import type { HookContext } from '@deeep-network/riptide'

module.exports = {
  installSecrets: async ({ logger }: HookContext) => {
    logger.info('Installing secrets')
    return { success: true }
  },

  start: async ({ logger }: HookContext) => {
    logger.info('Service starting')
  },

  health: async ({ logger }: HookContext) => {
    logger.debug('Health check')
    return true
  },

  stop: async ({ logger }: HookContext) => {
    logger.info('Service stopping')
  }
}
`}getHooksWithSecrets(){return`import type { HookContext } from '@deeep-network/riptide'
import {
  MissingSecretError,
  InvalidSecretError,
  DiagnoseRequiredError
} from '@deeep-network/riptide'

module.exports = {
  installSecrets: async ({ env, logger }: HookContext) => {
    logger.info('Validating secrets')
    
    const apiKey = env.API_KEY
    if (!apiKey) {
      throw new MissingSecretError('API_KEY is required')
    }

    try {
      const response = await fetch('https://api.example.com/validate', {
        headers: { 'x-api-key': apiKey }
      })

      if (response.status === 401) {
        throw new InvalidSecretError('Invalid API key')
      }

      if (!response.ok) {
        throw new DiagnoseRequiredError(\`API returned \${response.status}\`)
      }

      logger.info('Secrets validated successfully')
      return { success: true }
    } catch (error) {
      if (error instanceof Error && 'code' in error) {
        throw new DiagnoseRequiredError(\`Network error: \${error.message}\`)
      }
      throw error
    }
  },

  start: async ({ env, logger }: HookContext) => {
    const apiKey = env.API_KEY
    if (!apiKey) {
      throw new MissingSecretError('API_KEY is required')
    }

    logger.info('Service starting with validated API key')
  },

  health: async ({ logger }: HookContext) => {
    logger.debug('Health check')
    return true
  },

  heartbeat: async ({ logger }: HookContext) => {
    return {
      service: 'your-service',
      status: 'healthy',
      timestamp: new Date().toISOString()
    }
  },

  stop: async ({ logger }: HookContext) => {
    logger.info('Service stopping')
  }
}
`}getHooksWithProcess(){return`import type { HookContext } from '@deeep-network/riptide'
import { spawn, ChildProcess } from 'child_process'
import { MissingSecretError } from '@deeep-network/riptide'

let serviceProcess: ChildProcess | null = null

module.exports = {
  installSecrets: async ({ env, logger }: HookContext) => {
    logger.info('Checking required configuration')
    
    if (!env.SERVICE_CONFIG) {
      throw new MissingSecretError('SERVICE_CONFIG is required')
    }

    return { success: true }
  },

  start: async ({ env, logger }: HookContext) => {
    logger.info('Starting service process')
    
    return new Promise((resolve, reject) => {
      serviceProcess = spawn('/path/to/binary', [env.SERVICE_CONFIG || ''], {
        detached: true,
        stdio: ['ignore', 'pipe', 'pipe']
      })

      serviceProcess.on('spawn', () => {
        logger.info(\`Service process started with PID: \${serviceProcess?.pid}\`)
        resolve()
      })

      serviceProcess.on('error', (error) => {
        logger.error(\`Failed to start service process: \${error.message}\`)
        reject(error)
      })

      serviceProcess.stdout?.on('data', (data) => {
        logger.info(\`[SERVICE] \${data.toString().trim()}\`)
      })

      serviceProcess.stderr?.on('data', (data) => {
        logger.error(\`[SERVICE ERROR] \${data.toString().trim()}\`)
      })

      serviceProcess.unref()
    })
  },

  health: async ({ logger, utils }: HookContext) => {
    logger.debug('Checking service health')
    
    if (!serviceProcess || !serviceProcess.pid) {
      return false
    }

    try {
      process.kill(serviceProcess.pid, 0)
      return true
    } catch {
      return false
    }
  },

  stop: async ({ logger, utils }: HookContext) => {
    logger.info('Stopping service process')
    
    if (serviceProcess && serviceProcess.pid) {
      try {
        process.kill(serviceProcess.pid, 'SIGTERM')
        await utils.sleep(2000)
        
        try {
          process.kill(serviceProcess.pid, 0)
          process.kill(serviceProcess.pid, 'SIGKILL')
          logger.warn('Had to force kill service process')
        } catch {
          logger.info('Service process stopped gracefully')
        }
      } catch (error) {
        logger.debug('Service process already stopped')
      }
    }
    
    serviceProcess = null
  }
}
`}getHooksWithMetrics(){return`import type { HookContext } from '@deeep-network/riptide'

let requestCount = 0
let errorCount = 0
let serviceStartTime = Date.now()

module.exports = {
  installSecrets: async ({ logger }: HookContext) => {
    logger.info('Installing secrets')
    return { success: true }
  },

  start: async ({ logger }: HookContext) => {
    logger.info('Service starting')
    serviceStartTime = Date.now()
    
    setInterval(() => {
      requestCount += Math.floor(Math.random() * 10)
      if (Math.random() < 0.1) errorCount++
    }, 5000)
  },

  health: async ({ logger }: HookContext) => {
    logger.debug('Health check')
    return true
  },

  heartbeat: async () => {
    return {
      service: 'your-service',
      status: 'healthy',
      uptime_seconds: Math.floor((Date.now() - serviceStartTime) / 1000),
      request_count: requestCount,
      error_count: errorCount
    }
  },

  metrics: async () => {
    const uptime = Math.floor((Date.now() - serviceStartTime) / 1000)
    
    let output = ''
    output += '# HELP service_uptime_seconds Time since service started\\n'
    output += '# TYPE service_uptime_seconds gauge\\n'
    output += \`service_uptime_seconds \${uptime}\\n\\n\`
    
    output += '# HELP service_requests_total Total requests processed\\n'
    output += '# TYPE service_requests_total counter\\n'
    output += \`service_requests_total \${requestCount}\\n\\n\`
    
    output += '# HELP service_errors_total Total errors encountered\\n'
    output += '# TYPE service_errors_total counter\\n'
    output += \`service_errors_total \${errorCount}\\n\`
    
    return output
  },

  stop: async ({ logger }: HookContext) => {
    logger.info('Service stopping')
  }
}
`}async createDockerfile(e,t){let i=await this.checkIfInWorkspace(e)?`# DeEEP Network Service for ${t}

# ----------------------------------------
# Base 
# ----------------------------------------
FROM node:22-alpine AS base
RUN apk add --no-cache libc6-compat
RUN npm install -g pnpm@10.8.0 turbo@2.5.0
WORKDIR /app
COPY . .
RUN turbo prune reef-${t} --docker

# ----------------------------------------
# Turbo Builder and PNPM Deployment
# ----------------------------------------
FROM node:22-alpine AS builder
RUN apk add --no-cache libc6-compat
RUN npm install -g pnpm@10.8.0 turbo@2.5.0
WORKDIR /app
COPY --from=base /app/out/full/ .
RUN pnpm install 
COPY turbo.json tsconfig.json .
RUN pnpm turbo run build --filter=reef-${t}... 

# Create pnpm deployment (requires .npmrc to have inject-workspace-packages=true)
# This "materializes" the workspace packages into the node_modules directory
RUN pnpm deploy --prod --filter reef-${t} deploy

# ----------------------------------------
# Third-party Base 
# ----------------------------------------
FROM node:22-alpine AS ${t}-base

# Install system dependencies needed for ${t} service
RUN apk add --no-cache \\
    curl \\
    bash \\
    procps \\
    ca-certificates

WORKDIR /app

# Add any ${t}-specific setup here
# Example: Download binaries, create users, set up directories

# ----------------------------------------
# Riptide Runtime Layer
# ----------------------------------------
FROM ${t}-base AS riptide
RUN addgroup -g 1005 riptide && adduser -u 1005 -G riptide -D riptide

COPY --from=quay.io/nerdnode/riptide:latest /usr/local/bin/riptide /usr/local/bin/riptide
COPY --from=quay.io/nerdnode/riptide:latest /riptide-runtime/ /riptide-runtime/
RUN chmod +x /usr/local/bin/riptide
ENV PATH="/usr/local/bin:$PATH"
RUN mkdir -p /riptide && chown -R riptide:riptide /riptide
COPY --from=builder --chown=riptide:riptide /app/deploy/dist /riptide/dist
COPY --from=builder --chown=riptide:riptide /app/deploy/node_modules /riptide/node_modules
COPY --from=builder --chown=riptide:riptide /app/deploy/package.json /riptide/package.json
COPY --chown=riptide:riptide services/${t}/riptide.config.json /riptide/riptide.config.json

EXPOSE 3000
WORKDIR /riptide
USER riptide
ENV NODE_ENV=production
ENTRYPOINT ["/usr/local/bin/riptide"]
CMD ["start", "--config", "/riptide/riptide.config.json", "--hooks", "/riptide/dist/hooks.js"]
`:`# DeEEP Network Service for ${t}

# ----------------------------------------
# Builder Stage
# ----------------------------------------
FROM node:22-alpine AS builder
RUN apk add --no-cache libc6-compat
WORKDIR /app
COPY package.json package-lock.json ./

# Copy source code and config
COPY tsconfig.json ./
COPY tsup.config.ts ./
COPY src ./src

# Build the application
RUN npm install
RUN npm run build
RUN npm prune --omit=dev

# ----------------------------------------
# Third-party Base
# ----------------------------------------
FROM node:22-alpine AS ${t}-base

# Install system dependencies needed for ${t} service
RUN apk add --no-cache \\
    curl \\
    bash \\
    procps \\
    ca-certificates

WORKDIR /app

# Add any ${t}-specific setup here
# Example: Download binaries, create users, set up directories

# ----------------------------------------
# Riptide Runtime Layer
# ----------------------------------------
FROM ${t}-base AS riptide
RUN addgroup -g 1005 riptide && adduser -u 1005 -G riptide -D riptide
COPY --from=quay.io/nerdnode/riptide:latest /usr/local/bin/riptide /usr/local/bin/riptide
COPY --from=quay.io/nerdnode/riptide:latest /riptide-runtime/ /riptide-runtime/
RUN chmod +x /usr/local/bin/riptide
ENV PATH="/usr/local/bin:$PATH"
RUN mkdir -p /riptide && chown -R riptide:riptide /riptide
COPY --from=builder --chown=riptide:riptide /app/dist /riptide/dist
COPY --from=builder --chown=riptide:riptide /app/node_modules /riptide/node_modules
COPY --from=builder --chown=riptide:riptide /app/package.json /riptide/package.json
COPY --chown=riptide:riptide riptide.config.json /riptide/riptide.config.json

EXPOSE 3000
WORKDIR /riptide
USER riptide
ENV NODE_ENV=production
ENTRYPOINT ["/usr/local/bin/riptide"]
CMD ["start", "--config", "/riptide/riptide.config.json", "--hooks", "/riptide/dist/hooks.js"]
`;await h.writeFile(l.join(e,"Dockerfile"),i)}showNextSteps(e,t){console.log(`
Next steps:
-----------
1. Navigate to your service:
   \x1B[36mcd ${e}\x1B[0m

2. Install dependencies:
   \x1B[36mnpm install\x1B[0m

3. Build the service:
   \x1B[36mnpm run build\x1B[0m

4. Validate the hooks:
   \x1B[36mnpm run validate\x1B[0m

5. Build your service Docker image:
   \x1B[36mnpm run build:docker\x1B[0m

6. Run locally:
   \x1B[36mdocker run -e MY_SECRETS=your-secrets reef-${e}\x1B[0m

7. Customize the Dockerfile third-party base section:
   - Add specific system dependencies for your service
   - Download binaries, create users, set up directories
   - Modify the '${e}-base' stage as needed

8. Customize the hooks in src/hooks.ts for your specific requirements

NOTE: Riptide is a node application. If your base image does
not have node installed (v22+), install it in the Dockerfile.
`)}async checkIfInWorkspace(e){let t=l.resolve(e),r=l.parse(t).root;for(;t!==r;){try{return await h.access(l.join(t,"pnpm-workspace.yaml")),!0}catch{}t=l.dirname(t)}return!1}async getRiptideVersion(){try{let e=[l.join(__dirname,"..","package.json"),l.join(__dirname,"..","..","package.json"),l.join(__dirname,"..","..","..","@deeep-network","riptide","package.json"),l.join(__dirname,"..","..","node_modules","@deeep-network","riptide","package.json")];for(let t of e)try{let r=await h.readFile(t,"utf-8"),i=JSON.parse(r);if(i.name==="@deeep-network/riptide")return`^${i.version}`}catch{continue}try{return`^${require("@deeep-network/riptide/package.json").version}`}catch{}return this.logger.warn("Could not read riptide package.json, falling back to default version"),"^0.1.3"}catch{return this.logger.warn("Could not read riptide package.json, falling back to default version"),"^0.1.3"}}};async function T(o,e,t={}){await new C(o).scaffold({serviceName:e,...t})}n(T,"initService");var u=(0,j.default)({level:process.env.LOG_LEVEL||"info",transport:{target:"pino-pretty"}});async function J(){try{let o=process.argv[2];if(o==="--help"||o==="-h"||o==="help"){D();return}if(o==="--version"||o==="-v"||o==="version"){await q();return}let e=v("--config")||v("-c")||"./riptide.config.json",t=v("--hooks")||v("-h")||"./hooks.js";switch(o){case"init":await z();break;case"start":await $(e,t);break;case"validate":await K(e,t);break;case"health":await G();break;case"status":await B();break;case"verify":break;default:o?(u.error(`Unknown command: ${o}`),D(),process.exit(1)):await $(e,t)}}catch(o){u.error({error:o},"CLI command failed"),process.exit(1)}}n(J,"main");function v(o){let e=process.argv.indexOf(o);if(e>=0&&e+1<process.argv.length)return process.argv[e+1]}n(v,"getArgValue");function D(){console.log(`
Riptide - Self-contained service lifecycle management

USAGE:
  npx riptide [COMMAND] [OPTIONS]

COMMANDS:
  init <name>         Create a new Coral Reef service
  start               Start the service (default)
  validate            Validate configuration and hooks
  health              Check service health
  status              Show service status
  verify              Verify Dockerfile security compliance
  help, --help, -h    Show this help message
  version, --version  Show version information

INIT OPTIONS:
  --template TYPE     Template to use: basic, with-secrets, with-process, with-metrics (default: basic)
  --path PATH         Directory to create service in (default: current directory)
  --description DESC  Service description

OPTIONS:
  --config, -c PATH   Path to configuration file (default: ./riptide.config.json)
  --hooks PATH        Path to hooks file (default: ./hooks.js)

EXAMPLES:
  npx riptide init my-service    # Create new service
  npx riptide init my-service --template with-secrets
  npx riptide start              # Start service
  npx riptide validate           # Validate config and hooks
  npx riptide health             # Check service health
`)}n(D,"showHelp");async function q(){try{let o=await import("fs/promises"),e=await import("path"),t=[e.resolve(__dirname,"../package.json"),e.resolve(__dirname,"./package.json"),"/riptide-runtime/package.json",e.resolve(process.cwd(),"package.json")];for(let r of t)try{let i=await o.readFile(r,"utf-8"),s=JSON.parse(i);if(s.name==="@deeep-network/riptide"){console.log(`@deeep-network/riptide v${s.version}`);return}}catch{continue}console.log("@deeep-network/riptide (version unknown)")}catch{console.log("@deeep-network/riptide (version unknown)")}}n(q,"showVersion");async function $(o,e){try{let t=await import("fs/promises"),r=await import("path"),i=await t.readFile(o,"utf-8"),s=JSON.parse(i),c=await import(r.resolve(process.cwd(),e)),d=c.default||c;await new S(d,s,{}).start()}catch(t){u.error({error:t},"Failed to start service"),process.exit(1)}}n($,"startService");async function K(o,e){u.info("Validating riptide configuration and hooks...");try{let t=await import("fs/promises"),r=await import("path"),i=await t.readFile(o,"utf-8"),s=JSON.parse(i);u.info({config:s},"Configuration loaded successfully");let c=await import(r.resolve(process.cwd(),e)),d=c.default||c;u.info({availableHooks:Object.keys(d)},"Hooks loaded successfully"),u.info("\u2705 Validation completed successfully"),process.exit(0)}catch(t){u.error({error:t},"\u274C Validation failed"),process.exit(1)}}n(K,"validateService");async function G(){try{let e=await(await fetch("http://localhost:3000/health")).json();console.log("Health Status:",JSON.stringify(e,null,2)),e.status==="healthy"?process.exit(0):process.exit(1)}catch(o){u.error({error:o},"Failed to check health"),process.exit(1)}}n(G,"checkHealth");async function B(){try{let e=await(await fetch("http://localhost:3000/status")).json();console.log("Service Status:",JSON.stringify(e,null,2))}catch(o){u.error({error:o},"Failed to get status"),process.exit(1)}}n(B,"showStatus");async function z(){let o=process.argv[3];o||(u.error("Service name is required"),console.log("Usage: npx riptide init <service-name>"),process.exit(1)),/^[a-z0-9-]+$/.test(o)||(u.error("Service name must contain only lowercase letters, numbers, and hyphens"),process.exit(1));let e=v("--template")||"basic",t=v("--path")||".",r=v("--description"),i=["basic","with-secrets","with-process","with-metrics"];i.includes(e)||(u.error(`Invalid template: ${e}`),console.log(`Valid templates: ${i.join(", ")}`),process.exit(1));try{await T(u,o,{targetPath:t,template:e,description:r}),process.exit(0)}catch(s){u.error({error:s},"Failed to initialize service"),process.exit(1)}}n(z,"initServiceCommand");J();
