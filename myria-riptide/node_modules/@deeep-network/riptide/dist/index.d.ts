import { Logger } from 'pino';

interface HookContext {
    config: ServiceConfig;
    logger: Logger;
    env: NodeJS.ProcessEnv;
    utils: UtilityContext;
    [key: string]: any;
}
interface UtilityContext {
    sleep: (ms: number) => Promise<void>;
    retry: <T>(fn: () => Promise<T>, options?: RetryOptions) => Promise<T>;
    execCommand: (command: string, options?: ExecOptions) => Promise<ExecResult>;
    writeFile: (path: string, content: string, options?: WriteFileOptions) => Promise<void>;
    readFile: (path: string) => Promise<string>;
    fileExists: (path: string) => Promise<boolean>;
    downloadFile: (url: string, destination: string) => Promise<string>;
}
interface RetryOptions {
    maxAttempts?: number;
    delay?: number;
    backoffMultiplier?: number;
    maxDelay?: number;
}
interface ExecOptions {
    timeout?: number;
    user?: string;
    cwd?: string;
    env?: Record<string, string>;
}
interface ExecResult {
    stdout: string;
    stderr: string;
    exitCode: number;
}
interface WriteFileOptions {
    mode?: string;
    encoding?: BufferEncoding;
}
interface HookModule {
    installSecrets?: (context: HookContext) => Promise<{
        success: boolean;
        transformedSecrets?: Record<string, string>;
    }>;
    start: (context: HookContext) => Promise<void>;
    stop?: (context: HookContext) => Promise<void>;
    health: (context: HookContext) => Promise<boolean>;
    heartbeat?: (context: HookContext) => Promise<Record<string, any> | null>;
    status?: (context: HookContext) => Promise<ServiceStatus>;
    metrics?: (context: HookContext) => Promise<ServiceMetrics>;
}
interface ServiceConfig {
    service: {
        name: string;
        version?: string;
        description?: string;
    };
    health?: {
        port?: number;
    };
    heartbeat?: {
        interval?: number;
        enabled?: boolean;
    };
    logging?: {
        level?: 'debug' | 'info' | 'warn' | 'error';
        format?: 'json' | 'pretty';
    };
}
interface ServiceStatus {
    status: 'starting' | 'healthy' | 'unhealthy' | 'stopping' | 'stopped';
    uptime?: number;
    message?: string;
    details?: Record<string, any>;
}
interface ServiceMetrics {
    [key: string]: number | string | boolean;
}
interface RiptideEntrypointOptions {
    configPath?: string;
    hooksPath?: string;
    logLevel?: 'debug' | 'info' | 'warn' | 'error';
    dryRun?: boolean;
}

declare class RiptideEntrypoint {
    private logger;
    private hooks;
    private config;
    private isShuttingDown;
    private status;
    private startTime;
    private heartbeatInterval?;
    private webServer?;
    constructor(hooks: HookModule, config: ServiceConfig, options?: RiptideEntrypointOptions);
    start(): Promise<void>;
    private processSecrets;
    private executeHook;
    private executeHookSafely;
    private createHookContext;
    private setupGlobalErrorHandlers;
    private setupSignalHandlers;
    private startHeartbeat;
    private pingSonar;
    private startWebServer;
    private waitForShutdown;
    getMetrics(): Promise<any>;
}

declare function loadConfig(configPath: string): Promise<ServiceConfig>;
declare function loadHooks(hooksPath: string): Promise<HookModule>;
declare function validateConfig(config: ServiceConfig): void;
declare function getDefaultConfig(): Partial<ServiceConfig>;
declare function mergeConfigs(base: Partial<ServiceConfig>, override: Partial<ServiceConfig>): ServiceConfig;

interface LoggerOptions {
    level?: 'debug' | 'info' | 'warn' | 'error';
    format?: 'json' | 'pretty';
    serviceName: string;
}
declare function createLogger(options: LoggerOptions): Logger;
declare function createChildLogger(parentLogger: Logger, context: Record<string, any>): Logger;

declare function createUtilityContext(): UtilityContext;
declare function redactSecret(secret: string): string;
declare function parseEnvironmentVariables(input: string): Record<string, string>;
declare function expandEnvironmentVariables(input: string, env?: Record<string, string | undefined>): string;

interface ScaffoldOptions {
    serviceName: string;
    targetPath?: string;
    template?: 'basic' | 'with-secrets' | 'with-process' | 'with-metrics';
    description?: string;
}
declare class ServiceScaffolder {
    private logger;
    constructor(logger: Logger);
    scaffold(options: ScaffoldOptions): Promise<void>;
    private createDirectoryStructure;
    private createPackageJson;
    private createRiptideConfig;
    private createTsConfig;
    private createTsupConfig;
    private createHooks;
    private getBasicHooks;
    private getHooksWithSecrets;
    private getHooksWithProcess;
    private getHooksWithMetrics;
    private createDockerfile;
    private showNextSteps;
    private checkIfInWorkspace;
    private getRiptideVersion;
}
declare function initService(logger: Logger, serviceName: string, options?: Partial<ScaffoldOptions>): Promise<void>;

/**
 * Custom error classes for Riptide Entrypoint
 * These errors map to specific exit codes for container orchestration
 */
/**
 * Base class for all Riptide custom errors
 * Provides a reliable way to identify riptide-specific errors
 */
declare abstract class RiptideError extends Error {
    abstract readonly exitCode: number;
    constructor(message: string);
}
/**
 * Error indicating that manual intervention is required
 * Exit code: 3
 */
declare class DiagnoseRequiredError extends RiptideError {
    readonly exitCode = 3;
    constructor(message: string);
}
/**
 * Error indicating that a required secret is missing
 * Exit code: 4
 */
declare class MissingSecretError extends RiptideError {
    readonly exitCode = 4;
    constructor(message: string);
}
/**
 * Error indicating that a secret is invalid or malformed
 * Exit code: 5
 */
declare class InvalidSecretError extends RiptideError {
    readonly exitCode = 5;
    constructor(message: string);
}
/**
 * Error indicating that the service is already running somewhere and we can't start it again
 * Exit code: 6
 */
declare class AlreadyRunningError extends RiptideError {
    readonly exitCode = 6;
    constructor(message: string);
}
/**
 * Type guards for Riptide errors that work across module boundaries
 */
declare function isRiptideError(error: unknown): error is RiptideError;
declare function isDiagnoseRequiredError(error: unknown): error is DiagnoseRequiredError;
declare function isMissingSecretError(error: unknown): error is MissingSecretError;
declare function isInvalidSecretError(error: unknown): error is InvalidSecretError;
declare function isAlreadyRunningError(error: unknown): error is AlreadyRunningError;

export { AlreadyRunningError, DiagnoseRequiredError, type ExecOptions, type ExecResult, type HookContext, type HookModule, InvalidSecretError, MissingSecretError, type RetryOptions, RiptideEntrypoint, type RiptideEntrypointOptions, RiptideError, type ScaffoldOptions, type ServiceConfig, type ServiceMetrics, ServiceScaffolder, type ServiceStatus, type UtilityContext, type WriteFileOptions, createChildLogger, createLogger, createUtilityContext, expandEnvironmentVariables, getDefaultConfig, initService, isAlreadyRunningError, isDiagnoseRequiredError, isInvalidSecretError, isMissingSecretError, isRiptideError, loadConfig, loadHooks, mergeConfigs, parseEnvironmentVariables, redactSecret, validateConfig };
