"use strict";var Q=Object.create;var v=Object.defineProperty;var Z=Object.getOwnPropertyDescriptor;var ee=Object.getOwnPropertyNames;var te=Object.getPrototypeOf,re=Object.prototype.hasOwnProperty;var a=(r,e)=>v(r,"name",{value:e,configurable:!0});var oe=(r,e)=>{for(var t in e)v(r,t,{get:e[t],enumerable:!0})},T=(r,e,t,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of ee(e))!re.call(r,i)&&i!==t&&v(r,i,{get:()=>e[i],enumerable:!(o=Z(e,i))||o.enumerable});return r};var m=(r,e,t)=>(t=r!=null?Q(te(r)):{},T(e||!r||!r.__esModule?v(t,"default",{value:r,enumerable:!0}):t,r)),ie=r=>T(v({},"__esModule",{value:!0}),r);var pe={};oe(pe,{AlreadyRunningError:()=>C,DiagnoseRequiredError:()=>w,InvalidSecretError:()=>x,MissingSecretError:()=>S,RiptideEntrypoint:()=>H,RiptideError:()=>h,ServiceScaffolder:()=>k,createChildLogger:()=>A,createLogger:()=>b,createUtilityContext:()=>P,expandEnvironmentVariables:()=>R,getDefaultConfig:()=>G,initService:()=>z,isAlreadyRunningError:()=>N,isDiagnoseRequiredError:()=>M,isInvalidSecretError:()=>_,isMissingSecretError:()=>j,isRiptideError:()=>y,loadConfig:()=>V,loadHooks:()=>K,mergeConfigs:()=>B,parseEnvironmentVariables:()=>L,redactSecret:()=>W,validateConfig:()=>I});module.exports=ie(pe);var h=class r extends Error{static{a(this,"RiptideError")}constructor(e){super(e),Object.setPrototypeOf(this,r.prototype)}},w=class r extends h{static{a(this,"DiagnoseRequiredError")}exitCode=3;constructor(e){super(e),this.name="DiagnoseRequiredError",Object.setPrototypeOf(this,r.prototype)}},S=class r extends h{static{a(this,"MissingSecretError")}exitCode=4;constructor(e){super(e),this.name="MissingSecretError",Object.setPrototypeOf(this,r.prototype)}},x=class r extends h{static{a(this,"InvalidSecretError")}exitCode=5;constructor(e){super(e),this.name="InvalidSecretError",Object.setPrototypeOf(this,r.prototype)}},C=class r extends h{static{a(this,"AlreadyRunningError")}exitCode=6;constructor(e){super(e),this.name="AlreadyRunningError",Object.setPrototypeOf(this,r.prototype)}};function y(r){return r instanceof Error&&"exitCode"in r&&typeof r.exitCode=="number"}a(y,"isRiptideError");function M(r){return r instanceof Error&&r.name==="DiagnoseRequiredError"&&r.exitCode===3}a(M,"isDiagnoseRequiredError");function j(r){return r instanceof Error&&r.name==="MissingSecretError"&&r.exitCode===4}a(j,"isMissingSecretError");function _(r){return r instanceof Error&&r.name==="InvalidSecretError"&&r.exitCode===5}a(_,"isInvalidSecretError");function N(r){return r instanceof Error&&r.name==="AlreadyRunningError"&&r.exitCode===6}a(N,"isAlreadyRunningError");var E=m(require("pino"));function b(r){let{level:e="info",format:t="pretty",serviceName:o}=r,i={level:e,timestamp:E.default.stdTimeFunctions.isoTime,formatters:{log:a(s=>({service:o,...s}),"log"),bindings:a(s=>{let{pid:n,hostname:c,...u}=s;return u},"bindings")}};return t==="pretty"&&!process.env.NODE_ENV?.includes("prod")?(0,E.default)({...i,transport:{target:"pino-pretty",options:{colorize:!0,translateTime:"SYS:standard",ignore:"pid,hostname"}}}):(0,E.default)(i)}a(b,"createLogger");function A(r,e){return r.child(e)}a(A,"createChildLogger");var F=require("child_process"),g=require("fs"),se=m(require("http")),ne=m(require("https")),$=m(require("path")),U=require("util");var ae=(0,U.promisify)(F.exec);function P(){return{sleep:a(r=>new Promise(e=>setTimeout(e,r)),"sleep"),retry:a(async(r,e={})=>{let{maxAttempts:t=3,delay:o=1e3,backoffMultiplier:i=2,maxDelay:s=3e4}=e,n,c=o;for(let u=1;u<=t;u++)try{return await r()}catch(d){if(n=d instanceof Error?d:new Error(String(d)),u===t)throw n;await new Promise(f=>setTimeout(f,Math.min(c,s))),c*=i}throw n},"retry"),execCommand:a(async(r,e={})=>{let{timeout:t=3e4,cwd:o=process.cwd(),env:i=process.env}=e;try{let{stdout:s,stderr:n}=await ae(r,{timeout:t,cwd:o,env:{...process.env,...i}});return{stdout:s.trim(),stderr:n.trim(),exitCode:0}}catch(s){if(s.killed&&s.signal==="SIGTERM"){let c=`Command timed out after ${t/1e3}s. Consider increasing timeout if command needs more time to complete: utils.execCommand('${r}', { timeout: ${t*2} })`,u=s.stderr?.trim()||"",d=u?`${u}

${c}`:c,f=[];s.stdout?.trim()&&f.push(`STDOUT: ${s.stdout.trim()}`),d&&f.push(`STDERR: ${d}`);let X=[`Command execution timed out: ${r}`,...f].join(`

`),D=new Error(X);throw D.name="CommandTimeoutError",D}return{stdout:s.stdout?.trim()||"",stderr:s.stderr?.trim()||s.message,exitCode:s.code||1}}},"execCommand"),writeFile:a(async(r,e,t={})=>{let{mode:o="0644",encoding:i="utf8"}=t;await g.promises.mkdir($.dirname(r),{recursive:!0}),await g.promises.writeFile(r,e,{encoding:i}),await g.promises.chmod(r,o)},"writeFile"),readFile:a(async r=>await g.promises.readFile(r,"utf8"),"readFile"),fileExists:a(async r=>{try{return await g.promises.access(r),!0}catch{return!1}},"fileExists"),downloadFile:a(async function r(e,t){return new Promise((o,i)=>{let s=$.dirname(t);g.promises.mkdir(s,{recursive:!0}).then(()=>{let n=(0,g.createWriteStream)(t);(e.startsWith("https:")?ne:se).get(e,d=>{if(d.statusCode===200)d.pipe(n),n.on("finish",()=>{n.close(),o(t)});else if(d.statusCode===301||d.statusCode===302){let f=d.headers.location;f?o(r(f,t)):i(new Error(`Redirect without location header: ${d.statusCode}`))}else i(new Error(`Failed to download: ${d.statusCode} ${d.statusMessage}`))}).on("error",d=>{g.promises.unlink(t).catch(()=>{}),i(d)}),n.on("error",d=>{g.promises.unlink(t).catch(()=>{}),i(d)})}).catch(i)})},"downloadFile")}}a(P,"createUtilityContext");function W(r){return!r||r.length<=10?"[REDACTED]":`${r.slice(0,4)}...${r.slice(-4)}`}a(W,"redactSecret");function L(r){let e={},t=r.split(`
`);for(let o of t){let i=o.trim();if(i&&!i.startsWith("#")){let[s,...n]=i.split("=");s&&n.length>0&&(e[s.trim()]=n.join("=").trim())}}return e}a(L,"parseEnvironmentVariables");function R(r,e=process.env){return r.replace(/\$\{([^}]+)\}/g,(t,o)=>e[o]||t)}a(R,"expandEnvironmentVariables");var q=require("http");var O=class{constructor(e,t,o,i,s){this.getStatus=o;this.executeHealthCheck=i;this.getMetrics=s;this.port=e,this.logger=t.child({component:"web-server"})}static{a(this,"WebServer")}server=null;port;logger;async start(){if(this.server){this.logger.warn("Web server already running");return}return this.server=(0,q.createServer)(async(e,t)=>{if(e.method!=="GET"){t.writeHead(405,{"Content-Type":"application/json"}),t.end(JSON.stringify({error:"Method not allowed"}));return}if(e.url==="/health")try{let o=await this.executeHealthCheck(),i=this.getStatus(),s={healthy:o,status:i.status,uptime:i.uptime,message:i.message};o?t.writeHead(200,{"Content-Type":"application/json"}):t.writeHead(503,{"Content-Type":"application/json"}),t.end(JSON.stringify(s))}catch(o){this.logger.error({error:o},"Health check endpoint error"),t.writeHead(500,{"Content-Type":"application/json"}),t.end(JSON.stringify({healthy:!1,error:o instanceof Error?o.message:"Internal server error"}))}else if(e.url==="/metrics")try{let o=await this.getMetrics();t.writeHead(200,{"Content-Type":"text/plain; version=0.0.4"}),t.end(o)}catch(o){this.logger.error({error:o},"Metrics endpoint error"),t.writeHead(500,{"Content-Type":"application/json"}),t.end(JSON.stringify({error:o instanceof Error?o.message:"Internal server error"}))}else t.writeHead(404,{"Content-Type":"application/json"}),t.end(JSON.stringify({error:"Not found"}))}),new Promise((e,t)=>{this.server.once("error",o=>{this.logger.error({error:o,port:this.port},"Failed to start web server"),t(o)}),this.server.listen(this.port,()=>{e()})})}async stop(){if(this.server)return new Promise(e=>{this.server.close(()=>{this.logger.info("Web server stopped"),this.server=null,e()})})}};var H=class{static{a(this,"RiptideEntrypoint")}logger;hooks;config;isShuttingDown=!1;status={status:"starting"};startTime;heartbeatInterval;webServer;constructor(e,t,o={}){this.hooks=e,this.config=t,this.startTime=Date.now(),this.logger=b({serviceName:t.service.name,level:o.logLevel||t.logging?.level||"info",format:process.env.NODE_ENV==="production"?"json":t.logging?.format||"pretty"}),this.setupGlobalErrorHandlers(),this.setupSignalHandlers()}async start(){try{let e=this.config.service.version||"unknown",t=process.env.NODE_ENV||"production";this.logger.info({version:e,environment:t},`Starting ${this.config.service.name}`),await this.processSecrets(),await this.executeHook("start"),await this.startWebServer(this.config.health?.port||3e3),this.startHeartbeat(),this.status={status:"healthy",uptime:Date.now()-this.startTime,message:"Service started successfully"},this.logger.info({service:this.config.service.name},`${this.config.service.name} service is ready`),await this.waitForShutdown()}catch(e){this.logger.error({error:e instanceof Error?e.message:String(e),stack:e instanceof Error?e.stack:void 0},`Failed to start ${this.config.service.name} service`),this.status={status:"unhealthy",message:e instanceof Error?e.message:String(e)},y(e)?(this.logger.error(`Exiting with code ${e.exitCode} (${e.name})`),process.exit(e.exitCode)):process.exit(1)}}async processSecrets(){if(!this.hooks.installSecrets){this.logger.info("No installSecrets hook, continuing...");return}this.logger.info("Processing secrets...");try{await this.executeHook("installSecrets")}catch(e){throw this.logger.error({error:e instanceof Error?e.message:String(e),stack:e instanceof Error?e.stack:void 0,hookName:"installSecrets"},"Failed to install secrets"),e}}async executeHook(e){let t=this.hooks[e];if(typeof t!="function")throw new Error(`Required hook '${e}' not found`);let o=this.createHookContext(),i=Date.now();try{let s=await t(o),n=Date.now()-i;return this.logger.debug(`Hook ${e} completed in ${n}ms`),s}catch(s){let n=Date.now()-i;throw this.logger.error({hookName:e,duration:n,error:s instanceof Error?s.message:String(s),stack:s instanceof Error?s.stack:void 0},"Hook threw an exception, will not continue"),s}}async executeHookSafely(e){if(typeof this.hooks[e]!="function")return this.logger.debug(`Optional hook '${e}' not found, skipping`),null;try{return await this.executeHook(e)}catch(o){return this.logger.warn({hookName:e,error:o instanceof Error?o.message:String(o)},"Optional hook execution failed but continuing"),null}}createHookContext(){return{config:this.config,logger:this.logger,env:process.env,utils:P()}}setupGlobalErrorHandlers(){process.on("uncaughtException",e=>{this.logger.error({error:e.message,stack:e.stack},"Uncaught exception"),y(e)?(this.logger.info(`Exiting with code ${e.exitCode} (${e.name}) from unhandled exception`),process.exit(e.exitCode)):(this.logger.error("Exiting with code 1 due to unhandled exception"),process.exit(1))}),process.on("unhandledRejection",(e,t)=>{this.logger.error({reason:e,promise:t},"Unhandled promise rejection"),y(e)?(this.logger.info(`Exiting with code ${e.exitCode} (${e.name}) from unhandled rejection`),process.exit(e.exitCode)):(this.logger.error("Exiting with code 1 due to unhandled promise rejection"),process.exit(1))})}setupSignalHandlers(){let e=a(async t=>{this.isShuttingDown&&(this.logger.warn("Force shutdown signal received"),process.exit(1)),this.isShuttingDown=!0,this.status={status:"stopping",message:`Received ${t} signal`},this.logger.info(`${t} signal received, starting graceful shutdown...`);try{this.heartbeatInterval&&clearInterval(this.heartbeatInterval),this.webServer&&await this.webServer.stop(),await this.executeHookSafely("stop"),this.status={status:"stopped",message:"Graceful shutdown completed"},this.logger.info("Graceful shutdown completed"),process.exit(0)}catch(o){this.logger.error({error:o instanceof Error?o.message:String(o)},"Error during graceful shutdown"),process.exit(1)}},"gracefulShutdown");process.on("SIGTERM",()=>e("SIGTERM")),process.on("SIGINT",()=>e("SIGINT"))}startHeartbeat(){if(!this.hooks.heartbeat){this.logger.info("No heartbeat hook defined, skipping heartbeat");return}if(!this.config.heartbeat?.enabled){this.logger.info("Heartbeat disabled in config, skipping...");return}let e=this.config.heartbeat?.interval||6e4;this.logger.info({interval:e},"Starting heartbeat");let t=!1;this.heartbeatInterval=setInterval(async()=>{if(t){this.logger.info("Heartbeat still executing, skipping this interval");return}t=!0;try{let o=await this.executeHookSafely("heartbeat");if(o===null){this.logger.info("Heartbeat hook returned null, skipping heartbeat");return}await this.pingSonar(o)}catch(o){this.logger.warn({error:o instanceof Error?o.message:String(o)},"Heartbeat execution failed")}finally{t=!1}},e)}async pingSonar(e){let t=process.env.SONAR_API_URL,o=process.env.SONAR_API_KEY,i=process.env.NOMAD_JOB_NAME;if(!t||!o||!i){this.logger.info({hasUrl:!!t,hasKey:!!o,hasJobId:!!i},"Sonar API configuration incomplete, skipping heartbeat send");return}let s=Math.floor(Date.now()/1e3),n={entity_id:i,client_timestamp:s,metadata:e};try{this.logger.info({payload:n,sonarUrl:t,sonarApiKey:o,nomadJobId:i},"Sending heartbeat to Sonar API");let c=await fetch(`${t}/api/v1/heartbeat`,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${o}`},body:JSON.stringify(n)});if(!c.ok){let u=await c.text();this.logger.warn({status:c.status,error:u,entity_id:i},"Sonar API heartbeat failed")}}catch(c){this.logger.error({error:c instanceof Error?c.message:String(c),errorType:c?.constructor?.name,errorCause:c instanceof Error&&"cause"in c?c.cause:void 0,stack:c instanceof Error?c.stack:void 0,url:`${t}/api/v1/heartbeat`,entity_id:i},"Failed to send heartbeat to Sonar API")}}async startWebServer(e){this.webServer=new O(e,this.logger,()=>({...this.status,uptime:Date.now()-this.startTime}),async()=>await this.executeHookSafely("health")===!0,async()=>await this.getMetrics());try{await this.webServer.start()}catch(t){this.logger.error({error:t,port:e},"Failed to start web server")}}async waitForShutdown(){return new Promise(e=>{let t=a(()=>{this.isShuttingDown?e():setTimeout(t,100)},"checkShutdown");t()})}async getMetrics(){if(!this.hooks.metrics)return{uptime:Date.now()-this.startTime,status:this.status.status};try{return await this.executeHookSafely("metrics")}catch{return{uptime:Date.now()-this.startTime,status:this.status.status}}}};var Y=require("fs"),J=m(require("path"));async function V(r){try{let e=await Y.promises.readFile(r,"utf8"),t=JSON.parse(e),o=ce(t);return I(o),o}catch(e){throw new Error(`Failed to load config from ${r}: ${e instanceof Error?e.message:String(e)}`)}}a(V,"loadConfig");async function K(r){try{let e=J.resolve(r);delete require.cache[e];let t=require(e);if(typeof t.start!="function")throw new Error('Hooks module must export a "start" function');return t}catch(e){throw new Error(`Failed to load hooks from ${r}: ${e instanceof Error?e.message:String(e)}`)}}a(K,"loadHooks");function I(r){if(!r.service?.name)throw new Error("Config must have service.name");if(r.health,r.heartbeat&&r.heartbeat.interval&&r.heartbeat.interval<1e3)throw new Error("heartbeat.interval must be at least 1000ms")}a(I,"validateConfig");function ce(r,e=process.env){let t=JSON.parse(JSON.stringify(r));function o(i){if(typeof i=="string")return R(i,e);if(Array.isArray(i))return i.map(o);if(i&&typeof i=="object"){let s={};for(let[n,c]of Object.entries(i))s[n]=o(c);return s}return i}return a(o,"expandObject"),o(t)}a(ce,"expandConfigVariables");function G(){return{health:{port:3e3},heartbeat:{interval:6e4,enabled:!1},logging:{level:"info",format:"pretty"}}}a(G,"getDefaultConfig");function B(r,e){function t(i,s){if(s&&typeof s=="object"&&!Array.isArray(s))for(let n in s)s.hasOwnProperty(n)&&(i[n]&&typeof i[n]=="object"&&!Array.isArray(i[n])?i[n]=t(i[n],s[n]):i[n]=s[n]);return i}a(t,"deepMerge");let o=t({...r},e);return I(o),o}a(B,"mergeConfigs");var l=m(require("fs/promises")),p=m(require("path"));var k=class{constructor(e){this.logger=e}static{a(this,"ServiceScaffolder")}async scaffold(e){let{serviceName:t,targetPath:o=".",template:i="basic",description:s}=e,n=p.join(o,t);this.logger.info(`Creating new Coral Reef service: ${t}`),this.logger.info(`Template: ${i}`),this.logger.info(`Location: ${n}`),await this.createDirectoryStructure(n),await this.createPackageJson(n,t,s),await this.createRiptideConfig(n,t,s),await this.createTsConfig(n),await this.createTsupConfig(n),await this.createHooks(n,i),await this.createDockerfile(n,t),this.logger.info("\u2705 Service scaffolding complete!"),this.showNextSteps(t,n)}async createDirectoryStructure(e){await l.mkdir(p.join(e,"src"),{recursive:!0})}async createPackageJson(e,t,o){let i=await this.checkIfInWorkspace(e),s=i?"workspace:*":await this.getRiptideVersion(),n=i?`cd ../.. && docker build --platform \${DOCKER_PLATFORM:-linux/amd64} --progress=plain -t reef-${t} -f services/${t}/Dockerfile .`:`docker build --platform \${DOCKER_PLATFORM:-linux/amd64} --progress=plain -t reef-${t} .`,c={name:`reef-${t}`,version:"1.0.0",description:o||`${t} service for Coral Reef`,main:"dist/hooks.js",scripts:{build:"tsc --noEmit && tsup","build:docker":n,clean:"rm -rf dist",start:"npx @deeep-network/riptide start --hooks dist/hooks.js",validate:"pnpm run build && npx @deeep-network/riptide validate --hooks dist/hooks.js","type-check":"tsc --noEmit"},dependencies:{"@deeep-network/riptide":s},devDependencies:{typescript:"^5.8.3",tsup:"^8.5.0","@types/node":"^20.0.0"},engines:{node:">=22.0.0"}};await l.writeFile(p.join(e,"package.json"),JSON.stringify(c,null,2))}async createRiptideConfig(e,t,o){let i={service:{name:t,version:"1.0.0",description:o||`${t} service`},logging:{level:"info"}};await l.writeFile(p.join(e,"riptide.config.json"),JSON.stringify(i,null,2))}async createTsConfig(e){let o=await this.checkIfInWorkspace(e)?{extends:"../../tsconfig.json",compilerOptions:{outDir:"./dist",rootDir:"./src",declaration:!0,declarationMap:!0,sourceMap:!0},include:["src/**/*"],exclude:["dist","node_modules"]}:{compilerOptions:{target:"ES2022",module:"commonjs",lib:["ES2022"],outDir:"./dist",rootDir:"./src",strict:!0,esModuleInterop:!0,skipLibCheck:!0,forceConsistentCasingInFileNames:!0,declaration:!0,declarationMap:!0,sourceMap:!0,moduleResolution:"node"},include:["src/**/*"],exclude:["dist","node_modules"]};await l.writeFile(p.join(e,"tsconfig.json"),JSON.stringify(o,null,2))}async createTsupConfig(e){await l.writeFile(p.join(e,"tsup.config.ts"),`import { defineConfig } from 'tsup'

export default defineConfig({
  entry: ['src/hooks.ts'],
  format: ['cjs'],
  target: 'node22',
  outDir: 'dist',
  clean: true,
  minify: false,
  sourcemap: true
})
`)}async createHooks(e,t){let o="";switch(t){case"with-secrets":o=this.getHooksWithSecrets();break;case"with-process":o=this.getHooksWithProcess();break;case"with-metrics":o=this.getHooksWithMetrics();break;default:o=this.getBasicHooks()}await l.writeFile(p.join(e,"src","hooks.ts"),o)}getBasicHooks(){return`import type { HookContext } from '@deeep-network/riptide'

module.exports = {
  installSecrets: async ({ logger }: HookContext) => {
    logger.info('Installing secrets')
    return { success: true }
  },

  start: async ({ logger }: HookContext) => {
    logger.info('Service starting')
  },

  health: async ({ logger }: HookContext) => {
    logger.debug('Health check')
    return true
  },

  stop: async ({ logger }: HookContext) => {
    logger.info('Service stopping')
  }
}
`}getHooksWithSecrets(){return`import type { HookContext } from '@deeep-network/riptide'
import {
  MissingSecretError,
  InvalidSecretError,
  DiagnoseRequiredError
} from '@deeep-network/riptide'

module.exports = {
  installSecrets: async ({ env, logger }: HookContext) => {
    logger.info('Validating secrets')
    
    const apiKey = env.API_KEY
    if (!apiKey) {
      throw new MissingSecretError('API_KEY is required')
    }

    try {
      const response = await fetch('https://api.example.com/validate', {
        headers: { 'x-api-key': apiKey }
      })

      if (response.status === 401) {
        throw new InvalidSecretError('Invalid API key')
      }

      if (!response.ok) {
        throw new DiagnoseRequiredError(\`API returned \${response.status}\`)
      }

      logger.info('Secrets validated successfully')
      return { success: true }
    } catch (error) {
      if (error instanceof Error && 'code' in error) {
        throw new DiagnoseRequiredError(\`Network error: \${error.message}\`)
      }
      throw error
    }
  },

  start: async ({ env, logger }: HookContext) => {
    const apiKey = env.API_KEY
    if (!apiKey) {
      throw new MissingSecretError('API_KEY is required')
    }

    logger.info('Service starting with validated API key')
  },

  health: async ({ logger }: HookContext) => {
    logger.debug('Health check')
    return true
  },

  heartbeat: async ({ logger }: HookContext) => {
    return {
      service: 'your-service',
      status: 'healthy',
      timestamp: new Date().toISOString()
    }
  },

  stop: async ({ logger }: HookContext) => {
    logger.info('Service stopping')
  }
}
`}getHooksWithProcess(){return`import type { HookContext } from '@deeep-network/riptide'
import { spawn, ChildProcess } from 'child_process'
import { MissingSecretError } from '@deeep-network/riptide'

let serviceProcess: ChildProcess | null = null

module.exports = {
  installSecrets: async ({ env, logger }: HookContext) => {
    logger.info('Checking required configuration')
    
    if (!env.SERVICE_CONFIG) {
      throw new MissingSecretError('SERVICE_CONFIG is required')
    }

    return { success: true }
  },

  start: async ({ env, logger }: HookContext) => {
    logger.info('Starting service process')
    
    return new Promise((resolve, reject) => {
      serviceProcess = spawn('/path/to/binary', [env.SERVICE_CONFIG || ''], {
        detached: true,
        stdio: ['ignore', 'pipe', 'pipe']
      })

      serviceProcess.on('spawn', () => {
        logger.info(\`Service process started with PID: \${serviceProcess?.pid}\`)
        resolve()
      })

      serviceProcess.on('error', (error) => {
        logger.error(\`Failed to start service process: \${error.message}\`)
        reject(error)
      })

      serviceProcess.stdout?.on('data', (data) => {
        logger.info(\`[SERVICE] \${data.toString().trim()}\`)
      })

      serviceProcess.stderr?.on('data', (data) => {
        logger.error(\`[SERVICE ERROR] \${data.toString().trim()}\`)
      })

      serviceProcess.unref()
    })
  },

  health: async ({ logger, utils }: HookContext) => {
    logger.debug('Checking service health')
    
    if (!serviceProcess || !serviceProcess.pid) {
      return false
    }

    try {
      process.kill(serviceProcess.pid, 0)
      return true
    } catch {
      return false
    }
  },

  stop: async ({ logger, utils }: HookContext) => {
    logger.info('Stopping service process')
    
    if (serviceProcess && serviceProcess.pid) {
      try {
        process.kill(serviceProcess.pid, 'SIGTERM')
        await utils.sleep(2000)
        
        try {
          process.kill(serviceProcess.pid, 0)
          process.kill(serviceProcess.pid, 'SIGKILL')
          logger.warn('Had to force kill service process')
        } catch {
          logger.info('Service process stopped gracefully')
        }
      } catch (error) {
        logger.debug('Service process already stopped')
      }
    }
    
    serviceProcess = null
  }
}
`}getHooksWithMetrics(){return`import type { HookContext } from '@deeep-network/riptide'

let requestCount = 0
let errorCount = 0
let serviceStartTime = Date.now()

module.exports = {
  installSecrets: async ({ logger }: HookContext) => {
    logger.info('Installing secrets')
    return { success: true }
  },

  start: async ({ logger }: HookContext) => {
    logger.info('Service starting')
    serviceStartTime = Date.now()
    
    setInterval(() => {
      requestCount += Math.floor(Math.random() * 10)
      if (Math.random() < 0.1) errorCount++
    }, 5000)
  },

  health: async ({ logger }: HookContext) => {
    logger.debug('Health check')
    return true
  },

  heartbeat: async () => {
    return {
      service: 'your-service',
      status: 'healthy',
      uptime_seconds: Math.floor((Date.now() - serviceStartTime) / 1000),
      request_count: requestCount,
      error_count: errorCount
    }
  },

  metrics: async () => {
    const uptime = Math.floor((Date.now() - serviceStartTime) / 1000)
    
    let output = ''
    output += '# HELP service_uptime_seconds Time since service started\\n'
    output += '# TYPE service_uptime_seconds gauge\\n'
    output += \`service_uptime_seconds \${uptime}\\n\\n\`
    
    output += '# HELP service_requests_total Total requests processed\\n'
    output += '# TYPE service_requests_total counter\\n'
    output += \`service_requests_total \${requestCount}\\n\\n\`
    
    output += '# HELP service_errors_total Total errors encountered\\n'
    output += '# TYPE service_errors_total counter\\n'
    output += \`service_errors_total \${errorCount}\\n\`
    
    return output
  },

  stop: async ({ logger }: HookContext) => {
    logger.info('Service stopping')
  }
}
`}async createDockerfile(e,t){let i=await this.checkIfInWorkspace(e)?`# DeEEP Network Service for ${t}

# ----------------------------------------
# Base 
# ----------------------------------------
FROM node:22-alpine AS base
RUN apk add --no-cache libc6-compat
RUN npm install -g pnpm@10.8.0 turbo@2.5.0
WORKDIR /app
COPY . .
RUN turbo prune reef-${t} --docker

# ----------------------------------------
# Turbo Builder and PNPM Deployment
# ----------------------------------------
FROM node:22-alpine AS builder
RUN apk add --no-cache libc6-compat
RUN npm install -g pnpm@10.8.0 turbo@2.5.0
WORKDIR /app
COPY --from=base /app/out/full/ .
RUN pnpm install 
COPY turbo.json tsconfig.json .
RUN pnpm turbo run build --filter=reef-${t}... 

# Create pnpm deployment (requires .npmrc to have inject-workspace-packages=true)
# This "materializes" the workspace packages into the node_modules directory
RUN pnpm deploy --prod --filter reef-${t} deploy

# ----------------------------------------
# Third-party Base 
# ----------------------------------------
FROM node:22-alpine AS ${t}-base

# Install system dependencies needed for ${t} service
RUN apk add --no-cache \\
    curl \\
    bash \\
    procps \\
    ca-certificates

WORKDIR /app

# Add any ${t}-specific setup here
# Example: Download binaries, create users, set up directories

# ----------------------------------------
# Riptide Runtime Layer
# ----------------------------------------
FROM ${t}-base AS riptide
RUN addgroup -g 1005 riptide && adduser -u 1005 -G riptide -D riptide

COPY --from=quay.io/nerdnode/riptide:latest /usr/local/bin/riptide /usr/local/bin/riptide
COPY --from=quay.io/nerdnode/riptide:latest /riptide-runtime/ /riptide-runtime/
RUN chmod +x /usr/local/bin/riptide
ENV PATH="/usr/local/bin:$PATH"
RUN mkdir -p /riptide && chown -R riptide:riptide /riptide
COPY --from=builder --chown=riptide:riptide /app/deploy/dist /riptide/dist
COPY --from=builder --chown=riptide:riptide /app/deploy/node_modules /riptide/node_modules
COPY --from=builder --chown=riptide:riptide /app/deploy/package.json /riptide/package.json
COPY --chown=riptide:riptide services/${t}/riptide.config.json /riptide/riptide.config.json

EXPOSE 3000
WORKDIR /riptide
USER riptide
ENV NODE_ENV=production
ENTRYPOINT ["/usr/local/bin/riptide"]
CMD ["start", "--config", "/riptide/riptide.config.json", "--hooks", "/riptide/dist/hooks.js"]
`:`# DeEEP Network Service for ${t}

# ----------------------------------------
# Builder Stage
# ----------------------------------------
FROM node:22-alpine AS builder
RUN apk add --no-cache libc6-compat
WORKDIR /app
COPY package.json package-lock.json ./

# Copy source code and config
COPY tsconfig.json ./
COPY tsup.config.ts ./
COPY src ./src

# Build the application
RUN npm install
RUN npm run build
RUN npm prune --omit=dev

# ----------------------------------------
# Third-party Base
# ----------------------------------------
FROM node:22-alpine AS ${t}-base

# Install system dependencies needed for ${t} service
RUN apk add --no-cache \\
    curl \\
    bash \\
    procps \\
    ca-certificates

WORKDIR /app

# Add any ${t}-specific setup here
# Example: Download binaries, create users, set up directories

# ----------------------------------------
# Riptide Runtime Layer
# ----------------------------------------
FROM ${t}-base AS riptide
RUN addgroup -g 1005 riptide && adduser -u 1005 -G riptide -D riptide
COPY --from=quay.io/nerdnode/riptide:latest /usr/local/bin/riptide /usr/local/bin/riptide
COPY --from=quay.io/nerdnode/riptide:latest /riptide-runtime/ /riptide-runtime/
RUN chmod +x /usr/local/bin/riptide
ENV PATH="/usr/local/bin:$PATH"
RUN mkdir -p /riptide && chown -R riptide:riptide /riptide
COPY --from=builder --chown=riptide:riptide /app/dist /riptide/dist
COPY --from=builder --chown=riptide:riptide /app/node_modules /riptide/node_modules
COPY --from=builder --chown=riptide:riptide /app/package.json /riptide/package.json
COPY --chown=riptide:riptide riptide.config.json /riptide/riptide.config.json

EXPOSE 3000
WORKDIR /riptide
USER riptide
ENV NODE_ENV=production
ENTRYPOINT ["/usr/local/bin/riptide"]
CMD ["start", "--config", "/riptide/riptide.config.json", "--hooks", "/riptide/dist/hooks.js"]
`;await l.writeFile(p.join(e,"Dockerfile"),i)}showNextSteps(e,t){console.log(`
Next steps:
-----------
1. Navigate to your service:
   \x1B[36mcd ${e}\x1B[0m

2. Install dependencies:
   \x1B[36mnpm install\x1B[0m

3. Build the service:
   \x1B[36mnpm run build\x1B[0m

4. Validate the hooks:
   \x1B[36mnpm run validate\x1B[0m

5. Build your service Docker image:
   \x1B[36mnpm run build:docker\x1B[0m

6. Run locally:
   \x1B[36mdocker run -e MY_SECRETS=your-secrets reef-${e}\x1B[0m

7. Customize the Dockerfile third-party base section:
   - Add specific system dependencies for your service
   - Download binaries, create users, set up directories
   - Modify the '${e}-base' stage as needed

8. Customize the hooks in src/hooks.ts for your specific requirements

NOTE: Riptide is a node application. If your base image does
not have node installed (v22+), install it in the Dockerfile.
`)}async checkIfInWorkspace(e){let t=p.resolve(e),o=p.parse(t).root;for(;t!==o;){try{return await l.access(p.join(t,"pnpm-workspace.yaml")),!0}catch{}t=p.dirname(t)}return!1}async getRiptideVersion(){try{let e=[p.join(__dirname,"..","package.json"),p.join(__dirname,"..","..","package.json"),p.join(__dirname,"..","..","..","@deeep-network","riptide","package.json"),p.join(__dirname,"..","..","node_modules","@deeep-network","riptide","package.json")];for(let t of e)try{let o=await l.readFile(t,"utf-8"),i=JSON.parse(o);if(i.name==="@deeep-network/riptide")return`^${i.version}`}catch{continue}try{return`^${require("@deeep-network/riptide/package.json").version}`}catch{}return this.logger.warn("Could not read riptide package.json, falling back to default version"),"^0.1.3"}catch{return this.logger.warn("Could not read riptide package.json, falling back to default version"),"^0.1.3"}}};async function z(r,e,t={}){await new k(r).scaffold({serviceName:e,...t})}a(z,"initService");0&&(module.exports={AlreadyRunningError,DiagnoseRequiredError,InvalidSecretError,MissingSecretError,RiptideEntrypoint,RiptideError,ServiceScaffolder,createChildLogger,createLogger,createUtilityContext,expandEnvironmentVariables,getDefaultConfig,initService,isAlreadyRunningError,isDiagnoseRequiredError,isInvalidSecretError,isMissingSecretError,isRiptideError,loadConfig,loadHooks,mergeConfigs,parseEnvironmentVariables,redactSecret,validateConfig});
